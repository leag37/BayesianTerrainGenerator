/**************************************************************************************************
* Title: SmurfsVector2.cpp
* Authors: Gael Huber
* Description: 2-dimensional vector and associated operations
**************************************************************************************************/
#include "SmurfsVector2.h"

/**************************************************************************************************
* Constructor
**************************************************************************************************/
Vector2::Vector2(void) {
	x = 0.0f;
	y = 0.0f;
}

/**************************************************************************************************
* Constructor
*
* float x		x value
* float y		y value
**************************************************************************************************/
Vector2::Vector2(float x, float y) {
	this->x = x;
	this->y = y;
}

/**************************************************************************************************
* Destructor
**************************************************************************************************/
Vector2::~Vector2(void) {
	// Do nothing
}

/**************************************************************************************************
* Returns the magnitude of the vector
**************************************************************************************************/
float Vector2::magnitude(void) {
	return sqrt(x*x + y*y);
}

/**************************************************************************************************
* Returns a normalized version of the vector without altering the original vector
**************************************************************************************************/
Vector2 Vector2::getNormalized(void) {
	float mag = magnitude();	// What is the current magnitude?

	// If it is a zero vector, return a zero vector
	if(mag == 0.0f)
		return Vector2();

	return Vector2(x/mag, y/mag);
}

/**************************************************************************************************
* Normalizes the vector
**************************************************************************************************/
void Vector2::normalize(void) {
	float mag = magnitude();	// What is the current magnitude?

	// If it is not a zero vector, normalize
	if(mag != 0.0f) {
		x /= mag;
		y /= mag;
	}
}

/**************************************************************************************************
* Return the normal to this vector
**************************************************************************************************/
Vector2 Vector2::normalVector(void) {
	return Vector2(-y, x);
}

/**************************************************************************************************
* Dot product with another vector
**************************************************************************************************/
float Vector2::dot(Vector2 v) {
	return x * v.x + y * v.y;
}

// Floor of this vector
Vector2 Vector2::floor()
{
	return Vector2(std::floorf(x), std::floorf(y));
}

Vector2 Vector2::mod(int inMod)
{
	// First, cast values to integers
	int intX = static_cast<int>(x);
	int intY = static_cast<int>(y);

	// Mod each value
	intX %= inMod;
	intY %= inMod;

	// Convert back to float and return
	return Vector2(static_cast<float>(intX), static_cast<float>(intY));
}

/**************************************************************************************************
* Multiplication (dot product)
**************************************************************************************************/
Vector2 Vector2::operator*(const float &v) {
	return Vector2(x * v, y * v);
}

/**************************************************************************************************
* Addition
**************************************************************************************************/
Vector2 Vector2::operator+(const Vector2 &v) {
	return Vector2(x + v.x, y + v.y);
}

/**************************************************************************************************
* Subtraction
**************************************************************************************************/
Vector2 Vector2::operator-(const Vector2 &v) {
	return Vector2(x - v.x, y - v.y);
}

/**************************************************************************************************
* Division
**************************************************************************************************/
Vector2 Vector2::operator/(const float &v) {
	return Vector2(x / v, y / v);
}

/**************************************************************************************************
* Multiplication (dot product)
**************************************************************************************************/
void Vector2::operator*=(const float &v) {
	x *= v;
	y *= v;
}

/**************************************************************************************************
* Addition
**************************************************************************************************/
void Vector2::operator+=(const Vector2 &v) {
	x += v.x;
	y += v.y;
}

/**************************************************************************************************
* Subtraction
**************************************************************************************************/
void Vector2::operator-=(const Vector2 &v) {
	x -= v.x;
	y -= v.y;
}

/**************************************************************************************************
* Division
**************************************************************************************************/
void Vector2::operator/=(const float &v) {
	x /= v;
	y /= v;
}

Vector2 Vec2CosineInterpolation(const Vector2& a, const Vector2& b, float t)
{
	float ft = t * PI;
	float f = (1.0f - std::cosf(ft)) * 0.5f;

	return Vec2Scale(a, 1.0f - f) + Vec2Scale(b, f);
}

Vector2 Vec2Scale(const Vector2& v, float s)
{
	return Vector2(v.x * s, v.y * s);
}